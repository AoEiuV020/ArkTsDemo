1. 参考entry\src\main\ets\pages\Index.ets， 拆分出一个录音工具类，把所有技术细节封装， 只暴露出可能业务相关的内容，

1. 别看到vm就放进去， 你另外建个合适的目录，
1. 音频播放也是一样的道理封装起来， 

1. entry/src/main/ets/audio/AudioRecorder.ets:44 录音格式改成了amr wb, 其他相关代码你看着调整一下，
1. 包括后缀的定义也移到这里和其他参数靠近的位置，

1. ui这边每个调用都加上try catch log,

1. 参考entry\src\main\ets\pages\Index.ets, 拆出AudioCapturer的工具类， 把所有技术细节封装， 只暴露出可能业务相关的内容，

1. 参考ln/native/entry/src/main/cpp/AudioRecording.cpp 把录音功能实现到packages/audio_recorder/src/main/cpp，
1. 注意封装arkts到packages/audio_recorder/src/main/ets， arkts层只有工具类封装， 没有具体实现， 具体实现直接调用native函数，
   需要更改接口packages/audio_recorder/src/main/cpp/types/libaudio_recorder，
1. 最终把entry/src/main/ets/pages/Index.ets改用新的工具类，但用法要保持不变，

1. 挤在packages/audio_recorder/src/main/cpp/napi_init.cpp一个文件太糟糕了， 拆分， 首先必须有一个胶水层专门负责对arkts交互部分，
   其他文件应该可以是纯c++？看实际情况应该需要至少一个单独文件封装录音功能，尽量多拆分函数，起名准确，尽量提高可读性，

1. 录音参数保持和原本的一致，就是对标arm-wb，相关参数定义包括文件名后缀尽量靠近，

1. 不对， 我是说参数对标amr，但这个api明显录制出来是pcm，后缀写pcm,

1. 不止， 参考entry/src/main/ets/audio/AudioCapturer.ets:53有几个配置都设置上，

1. AUDIOSTREAM_SAMPLE_S16LE也放到packages/audio_recorder/src/main/cpp/AudioCapturer.cpp:19
1. 顺便注释一下当前参数下录音文件大小的计算式和结果，

1. 录音可以了，然后参考https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/audio-encoding 添加音频编码的封装，
   注意封装要细，不要混杂，编码相关单独一个文件， 重要的配置参数定义到一起， 先按网站例子中的参数定义， 然后注释一套目变amr-wb的参数配置，
1. 最好能实现边录边转码，实在不行才考虑先录制再转码，
1. 最终得到的应该是一个pcm文件， 一个编码后的文件， 编码后的文件全路径从外部传入，支持后缀pcm，后缀pcm代表不编码，
   只产出一个pcm文件， 其他后缀不判断， 内部处理参数， 外部设置文件，哪怕对不上也不管，

1. 我修复编译脚本， 现在可以重新按照.github\instructions\build.instructions.md编译，

1. 这不对， 我说了， 外部传入一个文件路径， 可以是pcm也可以是其他， 如果是pcm就只得到一个pcm文件， 如果是其他就得到pcm和其他两个文件，

1. 现在packages/audio_recorder/src/main/cpp/AudioCapturer.cpp:27参数重复定义了，
   我想能否复用packages/audio_recorder/src/main/cpp/AudioEncoderConfig.h:82 GetPcmConfig，
   而GetPcmConfig能否再复用GetAmrWbConfig，总之就是要方便切换，最好改一行代码就能切换，

1. packages/audio_recorder/src/main/cpp/AudioCapturer.cpp:6 采样大小计算注释转移到实际定义的地方，

1. 目前注释和功能对不上， 干脆整理一下， 我原本的想法是通过修改代码来切换aac/amr，但你却做了后缀判断，
   既然判断了后缀那就应该根据后缀使用对应的配置，而不是固定配置只改一个type,


1. arkts层的AudioCapturer改名audioRecorder，表示现在包含了采集和转码， 是个完善的录音器，


1.
参考ln/ffmpeg/ffmpeg/src/main/cpp/CMakeLists.txt添加packages/audio_recorder/src/main/cpp/thirdparty/opencore-amr的依赖，把amr编码改用这个库实现，
1. 这样项目内就有两套编码器了，做好接口和实现分离， 注意解耦，尽量不耦合到录音采集这块，尽量方便切换编码器，
   封装好目前依然是支持aac/amr， 后者使用opencore-amr， 注意只使用amrwb，你看能否把amrnb相关找出来删了，

1. 奇怪了， 为什么会缺amrwb的编码， 这个项目是否支持amrwb编码？官网在哪里，

1. 我下载了packages\audio_recorder\src\main\cpp\thirdparty\vo-amrwbenc ， 你看看要怎么使用？先讲讲别动手，

1. 不是问这个， 我是说工程上， 怎么编译这个库， cmake怎么使用这个库， 目标是支持鸿蒙x86_64+amr64,

1. 我看项目里有packages\audio_recorder\src\main\cpp\thirdparty\vo-amrwbenc\amrwbenc\Android.mk 这个是否能用上？毕竟鸿蒙和安卓这里应该差不太多？

1. 是否可能保持packages\audio_recorder\src\main\cpp\thirdparty\vo-amrwbenc不动，
   在外面哪里定义一个文件方便packages\audio_recorder\src\main\cpp\CMakeLists.txt引用，简化这里的依赖配置，

1. 行，就在vo-amrwbenc内部添加cmake, 然后使用，

1. 功能没问题， 系统编码器不要强调aac，以便拓展支持其他编码， 比如现在加个mp3支持，管理好配置参数， mp3/aac都走系统编码，
   复用编码器，传入配置，

1. entry\src\main\ets\pages\Index.ets 添加播放和删除缓存的按钮，
1. 播放使用entry\src\main\ets\audio\AudioPlayer.ets
1. 删除缓存在packages/audio_recorder/src/main/ets/AudioRecorder.ets添加函数， 传入编码后的文件，删除加上pcm文件，

1. 权限申请漏掉了， 

1. 优化entry/src/main/ets/pages/Index.ets，搞个vm出来，

1. vm添加大量日志打印， 简单封装一个日志函数，
1. 所有动作前后都打印日志，
1. 添加一个已打开的fd列表打印的函数， 初始化前和释放后打印，

1. 别叫IndexViewModel， 起个合适的名字，
1. vm层每个功能都应该try catch log,

1. 我发现播放器播放有fd泄露， 你看情况维护一下， 
