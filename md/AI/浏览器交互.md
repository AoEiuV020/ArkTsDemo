
1. entry/src/main/ets/pages/Index.ets 改成一个输入框一个按钮点击打开新浏览器页面，
1. 输入框默认地址 https://flutterdemo.aoeiuv020.com/
1. 实现新的浏览器页面， 要简单， 全屏，配置好基本功能， 然后打开url，
1. 新页面使用RelativeContainer做重叠ui，左上角摆一个返回键， 右下角摆一个刷新按钮，覆盖在内置浏览器上，

1. 用NavPathStack做页面跳转和参数传递， 
1. url参数是必须的， 不要重复硬编码默认值，

1. script\buildEts.js脚本没有正确输出错误信息这明显是脚本的问题，你不要固执的一直执行，检查一下脚本， 直接运行里面的编译命令对比看看过滤是不是有问题，先修复一下，然后再改代码，
1. Web控件基本能力配置好， 包括js之类的， 要能像个普通浏览器一样使用，

1. 我说了先修复脚本再改代码， 现在代码不报错了还怎么改脚本？
1. 脚本现在会打印不必要的内容，你看看怎么优化一下， 我要的是
- 尖括号开头行不显示
- 空行不显示
- 警告不显示，

1. 针对警告内容过滤也太离谱了， 以后有其他警告岂不是无效了， 
1. 或许可以考虑针对颜色，我看到的内容有白绿黄红， 看能否区分开来，然后只显示红色， 或者根据参数决定显示什么级别内容，

1. 浏览器啥也没加载， 我听说需要
    webview.WebviewController.initializeWebEngine()

1. 别太离谱， 到浏览器页面再初始化可以的吧，

1. 应该是需要网络权限，

1. 内置浏览器是否能无视CORS错误？

1. 参考ln\js\entry\src\main\ets\pages\Index.ets重做一下，当然，竖屏和全屏之类的是必须保留的，api用法初始化之类参考该项目，

模拟器里的内置浏览器时灵时不灵的， 应该和代码无关， 官方示例也是，

1. 参考ln\cors\entry\src\main\ets\views\RemoteRequest.ets， 通过拦截请求代理的方式实现cors跨域，

1. 别挤成一团， 一个类一个文件， 拆分好，封装好， 最终页面这里最好只要一行代码开启允许跨域就成，

1. 允许跨域参数做成开关显示在首页， 默认开启，

1. 目前跨域已拦截就白屏， 给我添加大量日志，包括Web本身的生命周期和各种状态能打的都打上，
1. 仔细对比一下拦截请求后的处理有没有什么问题，

1. 日志报错， [BrowserPage] onConsole [4] Uncaught (in promise) TypeError: Failed to execute 'compile' on 'WebAssembly':
   Incorrect response MIME type. Expected 'application/wasm'.

1. 被办法保留实际的mimetype吗？必须靠猜的吗？

1. 卡住了， 继续，

1. 奇怪了，明明断点检查了setMimeType确实是application/wasm，但还是报错Expected 'application/wasm'

1. 还是一样， 算力换个方案， 首页添加需要处理跨域的地址正则， 默认针对包含`/api/`的路径，
1. handleResponse部分还是参考原代码，

1. 不应该new直接enable, 应该持有示例，页面退出时得释放， clearWebSchemeHandler
1. 不是字符串匹配， 是要正则， 你来写个默认正则匹配包含`/api/`的路径，

1. 拦截可能导致报错， 看有没有办法改得更加通用一些，
   [BrowserPage] onConsole [2] [18:13:22] S CallService: API错误: 网络请求失败
   请求URL: https://xxx/call/api/rooms
   请求方法: POST
   请求数据: {secret: 5alijk9yb6Xcmt1cwQVTzkUM9svUvf24RWkr7UaAfIt68SIWITThP2vy90SQg2hk}
   Error: DioException [unknown]: null
   Error: FormatException: SyntaxError: Unexpected token '<', "<!DOCTYPE "... is not valid JSON
   [BrowserPage] onConsole [2] [18:13:22] S CallPage: Could not connect: 网络请求失败
   [BrowserPage] onConsole [2] [18:13:22] F MeetingRpc: sendNotification: onConnectionFailed, {message: 网络请求失败}

1. 你这不是啥也没干？就注释有屁用， 不实现post至少应该判断非get就不拦截吧，

1. ui上说明一下路径是正则， 另外不拦截非get，

1. 我要实现鸿蒙 - webview - flutter web交互，
1. 只需要最基本的字符串收发， 后续实现jsonrpc封装，
1. 目前鸿蒙entry\src\main\ets\pages\BrowserPage.ets这边加个按钮拟一个jsonrpc字符串调用函数hangUp没有参数写死字符串发送测试就好，注入对象接收消息不处理简单打印就好，
1. flutter web 部分在ln/livekit/lib/meeting_flutter_web.dart，目前只有判断内iframe内部就和父级window交互，
   需要添加非iframe的情况和原生平台交互，
1. web在ln/livekit/example/web/index.html， 添加一个独立的js，添加全局对象，负责封装原生平台交互， 抹平平台差异，
   只要收发字符串功能就好， 不要出现体现平台的标识，编写通用代码，不同平台定义相同的对象名， 鸿蒙和安卓一样， 可以在window下注入对象，
   因此使用相同的逻辑，定义一个注入对象名， 对象存在则使用， 不存在则按ios的常见做法处理，
1. js部分也可以添加iframe的判断和处理， 这样的话flutter这边就优先判断新全局对象是否存在，存在就使用，
   不管对象是父window还是android/ios/ohos, 全局对象不存在的情况保留旧的iframe判断处理,

1. FlutterNativeBridge/NativeBridge 考虑改个更通用清晰一点的名字，不要强调平台包括flutter，或许应该强调webview？

1. js里加个大段注释写点js代码能在浏览器里简单测试这个bridge的收发能力，

1. ln/livekit/example/web/native_bridge.js:128 ln/livekit/example/web/native_bridge.js:25 你这两个怎么能同名这不就冲突了，
   一个是js写死的对象， 一个是外部注入的对象， 仔细考虑一下，名字长点也没关系， 要清晰准确不体现平台，

1. 鸿蒙这边注册了需要取消注册，deleteJavaScriptRegister

1. flutter这边需要进入livekit_meeting/example执行编译检查， 这边处理了个空安全报错，
   flutter build web --debug
1. 参数不对`"params":[]`，该项目所有参数都是对象类型， 因此不要体现[]，改成{},代码和注释里都改，但这点不用明说，
1. messageListeners 梳理一下， 感觉不太对， 我要做的是在这里封装平台native或者window parent的交互，要实现任一个外部都是通过这个封装和flutter
   web交互，
   而flutter web支持两套交互， 一个是这个全局对象， 一个是旧的iframe上级，

1. 参数还是不对， 这个hangUp这种无参数的函数不能给params，直接没有这个字段，

1. 有效， 但是对于entry/src/main/ets/pages/BrowserPage.ets:173这种字符串拼接是不是很危险？特殊字符啥的感觉容易影响，
   挨个转义又容易bug，
1. 我考虑在native层将字符串编码后作为安全的参数传到js，js这里解码后再分发，
1. 考虑hex或者base64？要支持utf8中文和所有符号，还要保证任何浏览器都能处理，js层尽量简单，

1. 关于注释里的测试代码， 应该可以加一个覆盖send函数， 就能接收到flutter发出的消息，

1. 有效，但`decodeURIComponent(escape(atob`这是什么黑科技吗， js做一个简单的base64解码这么麻烦？而且escape还报了警告，
   The signature '(string: string): string' of 'escape' is deprecated.ts(6387)

1. entry/src/main/ets/pages/BrowserPage.ets封装好内外交互，封装jsonrpc到单独的的文件，jsonrpc核心参考如下代码，
   注意参考代码是iframe使用的，需要封装方便鸿蒙webview交互使用， 另外导包需要`from '@aoeiuv020/json_rpc_2'`
   封装完把原本的挂断按钮改成使用封装的工具处理，

```ts
import {
  JSONRPCServerAndClient,
  JSONRPCServer,
  JSONRPCClient,
} from "json-rpc-2.0";

export class JsonRpcIframe {
  private serverAndClient: JSONRPCServerAndClient;
  private remoteWindow: Window;

  constructor(remoteWindow: Window) {
    this.remoteWindow = remoteWindow;

    const server = new JSONRPCServer();
    const client = new JSONRPCClient((request) => {
      try {
        this.remoteWindow.postMessage(JSON.stringify(request), "*");
        return Promise.resolve();
      } catch (error) {
        return Promise.reject(error);
      }
    });

    this.serverAndClient = new JSONRPCServerAndClient(server, client);

    // 绑定消息事件监听
    window.addEventListener("message", this.onMessage.bind(this));
  }

  private onMessage(event: MessageEvent) {
    try {
      const data =
        typeof event.data === "string" ? JSON.parse(event.data) : event.data;
      if (data && typeof data === "object") {
        this.serverAndClient.receiveAndSend(data);
      }
    } catch (error) {
      console.error("Invalid JSON RPC message received:", event.data, error);
    }
  }

  public registerMethod<TParams, TResult>(
    name: string,
    handler: (params?: TParams) => TResult | Promise<TResult>
  ) {
    this.serverAndClient.addMethod(name, handler);
  }
  public unregisterMethod(name: string): void {
    this.serverAndClient.removeMethod(name);
  }

  public async sendRequest(method: string, params?: object): Promise<any> {
    return this.serverAndClient.request(method, params);
  }

  public sendNotification(method: string, params?: object): void {
    this.serverAndClient.notify(method, params);
  }

  public destroy() {
    window.removeEventListener("message", this.onMessage.bind(this));
    this.serverAndClient.rejectAllPendingRequests("Connection is closed.");
  }
}
```

1. src/main/ets/web/WebViewJsonRpc.ets:99 这里应该可以直接返回send异步，实现等待，

1. 别挤在一起， 几个类完全可以分几个文件，

1. 然后再加一个按钮调用setInterceptHangUpEnabled 参数enabled:true,
1. 再监听方法interceptHangUp，返回intercept:true, 拦截内部的挂断事件，同时自己弹出一个简单对话框，确认后发送挂断，
